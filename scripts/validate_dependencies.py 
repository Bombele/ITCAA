#!/usr/bin/env python3
"""
validate_dependencies.py
VÃ©rifie la cohÃ©rence des dÃ©pendances Python installÃ©es avec requirements.txt et requirements-dev.txt.
Institutionnalisation pour CI/CD ITCAA.
"""

import sys
import os
import pkg_resources

def log(msg: str):
    """Affiche un message institutionnel avec prÃ©fixe standardisÃ©."""
    print(f"ğŸ” [validate-deps] {msg}", flush=True)

def parse_requirements(file: str):
    """Charge et nettoie les dÃ©pendances depuis un fichier requirements."""
    with open(file, "r", encoding="utf-8") as f:
        return [
            line.strip() for line in f
            if line.strip() and not line.startswith("#")
        ]

def validate_requirements(file: str) -> bool:
    """Valide les dÃ©pendances par rapport Ã  un fichier requirements."""
    if not os.path.isfile(file):
        log(f"âš ï¸ Fichier {file} introuvable, validation ignorÃ©e.")
        return False  # fail-safe : absence = incohÃ©rence
    try:
        requirements = parse_requirements(file)
        pkg_resources.require(requirements)
        log(f"âœ… DÃ©pendances cohÃ©rentes avec {file}")
        return True
    except pkg_resources.DistributionNotFound as e:
        log(f"âŒ Paquet manquant requis par {file} â†’ {e}")
        return False
    except pkg_resources.VersionConflict as e:
        log(f"âŒ Conflit de version dÃ©tectÃ© dans {file} â†’ {e}")
        return False
    except pkg_resources.RequirementParseError as e:
        log(f"âŒ Erreur de parsing dans {file} â†’ {e}")
        return False
    except Exception as e:
        log(f"âŒ Erreur inattendue lors de la validation de {file} â†’ {e}")
        return False

def main():
    log("DÃ©marrage de la validation des dÃ©pendances Pythonâ€¦")
    ok = True
    for req_file in ["requirements.txt", "requirements-dev.txt"]:
        if not validate_requirements(req_file):
            ok = False
    if ok:
        log("ğŸ¯ Toutes les dÃ©pendances sont cohÃ©rentes.")
        sys.exit(0)
    else:
        log("ğŸš« DÃ©pendances incohÃ©rentes. Corrige avant CI/CD.")
        sys.exit(1)

if __name__ == "__main__":
    main()